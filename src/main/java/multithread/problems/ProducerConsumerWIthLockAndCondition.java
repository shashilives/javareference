package multithread.problems;import lombok.SneakyThrows;import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ProducerConsumerWIthLockAndCondition {    private static int consumer_wait_time = 300;    private static int producer_wait_time = 200;    private static int maxQueueCount = 4;    private static ReentrantLock lock = new ReentrantLock();    private static Condition notFull = lock.newCondition();    private static Condition notEmpty = lock.newCondition();    private static int i = 0;    public static void main(String[] args) {        Queue<Integer> queue = new LinkedList<>();        Thread producer = new Thread(new Producer(lock, queue));        Thread consumer = new Thread(new Consumer(lock, queue));        producer.start();        consumer.start();    }    static class Producer implements Runnable {        ReentrantLock lock;        Queue<Integer> queue;        public Producer(ReentrantLock lock, Queue<Integer> queue) {            this.lock = lock;            this.queue = queue;        }        @SneakyThrows        @Override        public void run() {            lock.lock();            while (true) {                try {                    while (queue.size() == maxQueueCount) {                        notFull.wait();                    }                    queue.add(i++);                    System.out.println("Producer Produced - " + Thread.currentThread().getName());                    notEmpty.signalAll();                } finally {                    lock.unlock();                }            }        }    }    static class Consumer implements Runnable {        ReentrantLock lock;        Condition condition;        Queue<Integer> queue;        public Consumer(ReentrantLock lock, Queue<Integer> queue) {            this.lock = lock;            this.queue = queue;        }        @SneakyThrows        @Override        public void run() {            lock.lock();            while (true) {                try {                    while (queue.size() == 0) {                        notEmpty.wait();                    }                    System.out.println("Consumer Consumed - " + Thread.currentThread().getName());                    queue.remove();                    notFull.signalAll();                } finally {                    lock.unlock();                }            }        }    }}