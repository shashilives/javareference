package multithread.problems;import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ProducerConsumerWIthLockAndCondition {    private static int consumer_wait_time = 300;    private static int producer_wait_time = 200;    private static int maxQueueCount = 4;    public static void main(String[] args) {        ReentrantLock lock = new ReentrantLock();        Condition condition = lock.newCondition();        Queue<Integer> queue = new LinkedList<>();        Thread producer = new Thread(new Producer(lock, condition, queue));        Thread consumer = new Thread(new Consumer(lock, condition, queue));        producer.start();        consumer.start();    }    static class Producer implements Runnable {        ReentrantLock lock;        Condition condition;        Queue<Integer> queue;        public Producer(ReentrantLock lock, Condition condition, Queue<Integer> queue) {            this.lock = lock;            this.condition = condition;            this.queue = queue;        }        @Override        public void run() {            int i = 0;            lock.lock();            while (true) {                try {                    Thread.sleep(producer_wait_time);                    while (queue.size() == maxQueueCount) {                        condition.await();                    }                    queue.add(i++);                    System.out.println("Producer Produced - " + Thread.currentThread().getName());                    condition.signal();                } catch (InterruptedException e) {                    e.printStackTrace();                    lock.unlock();                }            }        }    }    static class Consumer implements Runnable {        ReentrantLock lock;        Condition condition;        Queue<Integer> queue;        public Consumer(ReentrantLock lock, Condition condition, Queue<Integer> queue) {            this.lock = lock;            this.condition = condition;            this.queue = queue;        }        @Override        public void run() {            lock.lock();            while (true) {                try {                    Thread.sleep(consumer_wait_time);                    while (queue.size() == 0) {                        condition.await();                    }                    System.out.println("Consumer Consumed - " + Thread.currentThread().getName());                    queue.remove();                    condition.signal();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}